Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії








ЗВІТ
з практичної роботи №2
з дисципліни: «Аналіз та рефакторинг коду»








Виконав
ст. гр. ПЗПІ-23-4
Лінник Нікіта Анатолійович




Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	24.10.2025
	1
	Створено розділ «Завдання»
	2
	24.10.2025
	1
	Створено розділ «Хід роботи»
	3
	24.10.2025
	1
	Створено розділ «Висновки»
	4
	24.10.2025
	1
	Створено розділ «Додаток А»
	5
	24.10.2025
	1
	Створено розділ «Додаток Б»
	

2 ЗАВДАННЯ
Навчитися основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.


3 ХІД РОБОТИ
Рефакторинг — це процес поліпшення внутрішньої структури програмного коду без зміни його зовнішньої поведінки.
Інакше кажучи, програма після рефакторингу працює так само, але її код стає чистішим, зрозумілішим і легшим у підтримці.
Мета рефакторингу — підвищити якість коду:
- зробити його більш читабельним і структурованим;
- спростити пошук і виправлення помилок;
- забезпечити легкість розширення та повторного використання;
- зменшити технічний борг у проєкті.
Рефакторинг є невід’ємною частиною гнучкої розробки (Agile) і сприяє створенню чистого коду, про що детально розповідає Роберт Мартін у своїй книзі «Чистий код»


3.1 Extract Method (Виділення методу)
* Опис проблеми: у початковому коді функція processOrder() виконує одразу кілька дій: перевірку замовлення, розрахунок вартості, створення рахунку та надсилання повідомлення. Код стає занадто довгим і важким для розуміння, оскільки логіка різних етапів змішана в одному місці.
Проблеми:
- важко швидко зрозуміти, що саме робить функція;
- неможливо повторно використати частини коду в інших місцях;
- будь-яка зміна (наприклад, у розрахунку ціни) потребує перегляду всієї функції;
Вплив: це знижує читабельність і підтримуваність коду, підвищує ризик помилок під час внесення змін.


   * Код до рефакторингу
function processOrder(order) {
  // Перевірка валідності замовлення
  if (!order.items || order.items.length === 0) {
    throw new Error("Замовлення не містить товарів");
  }


  // Розрахунок загальної вартості
  let total = 0;
  for (let item of order.items) {
    total += item.price * item.quantity;
  }


  // Створення рахунку
  const invoice = {
    id: Date.now(),
    customer: order.customer,
    total: total,
  };


  // Надсилання повідомлення клієнту
  console.log(`Рахунок №${invoice.id} на суму ${invoice.total} грн відправлено клієнту ${invoice.customer}`);
}


   * Пояснення обраного методу: Метод Extract Method передбачає виділення логічно завершених частин коду в окремі функції. У нашому випадку — це перевірка, розрахунок, створення рахунку та сповіщення клієнта.
Чому саме цей метод оптимальний:
- зменшує розмір функції;
- робить код більш структурованим;
- полегшує тестування кожного етапу окремо;
- дозволяє повторно використовувати виділені методи в інших частинах програми;


      * Код після рефакторингу: 
function validateOrder(order) {
  if (!order.items || order.items.length === 0) {
    throw new Error("Замовлення не містить товарів");
  }
}


function calculateTotal(order) {
  return order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}


function createInvoice(order, total) {
  return {
    id: Date.now(),
    customer: order.customer,
    total: total,
  };
}


function notifyCustomer(invoice) {
  console.log(`Рахунок №${invoice.id} на суму ${invoice.total} грн відправлено клієнту ${invoice.customer}`);
}


function processOrder(order) {
  validateOrder(order);
  const total = calculateTotal(order);
  const invoice = createInvoice(order, total);
  notifyCustomer(invoice);
}


      * Переваги після рефакторингу:
Покращена читабельність:
- функція processOrder() тепер має вигляд набору чітких кроків бізнес-логіки.
Легше тестувати:
- кожну функцію (validateOrder, calculateTotal, тощо) можна тестувати окремо.
Зменшення дублювання:
- якщо потрібно повторно розрахувати вартість або перевірити замовлення — можна використати готові методи.
Краща підтримуваність:
- зміни в логіці одного етапу не впливають на інші частини коду.


3.2 Rename Variable (Перейменування змінної)
         * Опис проблеми: Після попереднього рефакторингу код став структурованішим, але деякі назви змінних залишились занадто загальними:
- total — незрозуміло, що це загальна сума, кількість чи щось інше;
- invoice — не очевидно, чи це рахунок, чи об’єкт із даними замовлення;
- o — змінна з циклу не несе сенсу;
- msg — не зрозуміло, що це саме повідомлення клієнту.
Проблеми:
        - назви не передають змісту, тому код потрібно “читати очима” замість того, щоб просто зрозуміти логіку; 
- новим розробникам або при підтримці через кілька місяців важко швидко розібратися;
        - ризик непорозумінь і помилок при подальших змінах.


            * Код до рефакторингу:
function processOrder(order) {
  validateOrder(order);


  let total = 0;
  for (let o of order.items) {
    total += o.price * o.quantity;
  }


  const invoice = {
    id: Date.now(),
    customer: order.customer,
    total: total,
  };


  const msg = `Рахунок №${invoice.id} на суму ${invoice.total} грн відправлено клієнту ${invoice.customer}`;
  console.log(msg);
}


            * Пояснення обраного методу: метод Rename Variable полягає в перейменуванні змінних, функцій чи параметрів для підвищення зрозумілості коду.Він не змінює поведінку програми, але робить її логіку очевидною та самодокументованою.
Чому саме цей метод оптимальний:
- дає змогу зробити код зрозумілішим без зміни його логіки;
        - полегшує спільну роботу в команді;
- зменшує кількість коментарів, бо самі назви пояснюють, що відбувається.

            * Код після рефакторингу
function processOrder(order) {
  validateOrder(order);


  let totalOrderAmount = 0;
  for (let item of order.items) {
    totalOrderAmount += item.price * item.quantity;
  }


  const customerInvoice = {
    id: Date.now(),
    customerName: order.customer,
    totalAmount: totalOrderAmount,
  };


  const customerNotificationMessage = 
    `Рахунок №${customerInvoice.id} на суму ${customerInvoice.totalAmount} грн ` +
    `відправлено клієнту ${customerInvoice.customerName}`;


  console.log(customerNotificationMessage);
}
            * Переваги після рефакторингу
Покращена читабельність: назви змінних тепер описують свій зміст — не потрібно вгадувати, що означає total чи msg.
Код став самодокументованим: без жодних коментарів зрозуміло, що customerInvoice — це рахунок, а customerNotificationMessage — текст повідомлення клієнту.
Зменшення неоднозначності: тепер кожна змінна має чітку роль, і це знижує ризик плутанини під час рефакторингу чи тестування.
Краща підтримуваність і розширюваність: якщо пізніше потрібно буде додати, наприклад, SMS або e-mail повідомлення, зрозуміло, куди це інтегрувати.






3.3 Extract Class (Виділення класу)
            * Опис проблеми: у процесі розвитку проєкту функція processOrder() поступово розрослася. Вона не лише обробляє замовлення, а й:
- перевіряє коректність даних;
- рахує загальну суму;
- створює рахунок;
- формує повідомлення для клієнта;
- виводить результат у консоль.
Таким чином, одна функція виконує декілька різних обов’язків, що порушує принцип єдиної відповідальності (Single Responsibility Principle).
Проблеми:
- важко тестувати окремі частини логіки;
- будь-яка зміна (наприклад, у способі сповіщення) вимагає редагування всієї функції;
- код важко розширювати — наприклад, додати e-mail або SMS повідомлення.
Вплив: код стає монолітним, складним для підтримки та повторного використання.


            * Код до рефакторингу
function processOrder(order) {
  // Перевірка
  if (!order.items || order.items.length === 0) {
    throw new Error("Замовлення не містить товарів");
  }


  // Розрахунок
  let totalOrderAmount = 0;
  for (let item of order.items) {
    totalOrderAmount += item.price * item.quantity;
  }


  // Створення рахунку
  const customerInvoice = {
    id: Date.now(),
    customerName: order.customer,
    totalAmount: totalOrderAmount,
  };


  // Повідомлення клієнта
  const customerNotificationMessage =
    `Рахунок №${customerInvoice.id} на суму ${customerInvoice.totalAmount} грн ` +
    `відправлено клієнту ${customerInvoice.customerName}`;


  console.log(customerNotificationMessage);
}


            * Пояснення обраного методу: метод Extract Class передбачає розділення великих класів або функцій на кілька менших, кожен з яких має єдину відповідальність.У нашому випадку логіку можна розділити на три окремі компоненти:
- OrderValidator — відповідає за перевірку замовлення;
- InvoiceService — створює рахунок і підраховує суму;
- NotificationService — відповідає за повідомлення клієнта.
Чому саме цей метод оптимальний:
- відокремлює логіку за ролями;
- полегшує підтримку, розширення та тестування;
- підтримує принципи SOLID, особливо SRP і OCP (Open/Closed Principle).
            * Код після рефакторингу
class OrderValidator {
  static validate(order) {
    if (!order.items || order.items.length === 0) {
      throw new Error("Замовлення не містить товарів");
    }
  }
}


class InvoiceService {
  static calculateTotal(order) {
    return order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }


  static createInvoice(order) {
    const totalAmount = this.calculateTotal(order);
    return {
      id: Date.now(),
      customerName: order.customer,
      totalAmount: totalAmount,
    };
  }
}


class NotificationService {
  static notifyCustomer(invoice) {
    const message =
      `Рахунок №${invoice.id} на суму ${invoice.totalAmount} грн ` +
      `відправлено клієнту ${invoice.customerName}`;
    console.log(message);
  }
}


// Тепер головна функція — лише координує процес:
function processOrder(order) {
  OrderValidator.validate(order);
  const invoice = InvoiceService.createInvoice(order);
  NotificationService.notifyCustomer(invoice);
}
            * Переваги після рефакторингу
Покращена читабельність: processOrder() тепер виконує лише роль “диригента”, а не містить деталі реалізації.
Єдина відповідальність: кожен клас виконує одну чітку задачу — валідація, рахунок, повідомлення.
Модульність: можна незалежно змінювати або тестувати кожен клас.
Легке розширення: наприклад, у NotificationService легко додати метод sendEmail() або інтеграцію з Telegram без змін у логіці processOrder.
Дотримання принципів SOLID: код став більш “чистим” і гнучким, що відповідає підходу Роберта Мартін


4 ВИСНОВКИ
Дотримання базових методів рефакторингу та рекомендацій під час написання коду є важливим не лише для створення працездатної програми, а й для забезпечення її читабельності, надійності та зручності підтримки. Ці підходи роблять програму легшою для сприйняття не тільки автором, але й іншими розробниками, підвищують ефективність командної роботи та спрощують розширення і модифікацію функціоналу в майбутньому.




5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Martin R. C. Clean Code: A Handbook of Agile Software Craftsmanship. 2009. 464 с.
















































ДОДАТОК А
Відео-посилання на YouTube: https://youtu.be/NF0_mUzbzi8
Хронологічний опис відеозапису:
00:00 - Вступ
00:14 - Опис мети
01:12 - Extract method
03:25 - Rename variable
05:53 - Extract Class
08:26 - Висновки




































ДОДАТОК Б
Скріншоти з презентації:
  

Рисунок Б.1 - Титульний лист


  

Рисунок Б.2 - Вступ


  

Рисунок Б.3 - Extract Method. Код до рефакторингу


  

Рисунок Б.4 - Extract Method. Код після рефакторингу


  

Рисунок Б.5 - Rename Variable. Код до рефакторингу


  

Рисунок Б.6 - Rename Variable. Код після рефакторингу


  

Рисунок Б.7 - Extract Class. Код до рефакторингу


  

Рисунок Б.8 - Extract Class. Код після рефакторингу


  

Рисунок Б.9 - Висновки


  

Рисунок Б.10 - Використані джерела
